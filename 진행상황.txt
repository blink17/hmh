https://hero.handmade.network/episodes

======================= 2016.07.15 (금) 
Day 003 까지 복습했음. 004할 차례

======================= 2016.07.19 (화)
Day 005 - 27분경 까지 학습. 코딩은 다쳐놨기 때문에 동영상만 쭉 보면 될듯

======================= 2016.07.20 (수)
Day 005 - 약간의 디버깅 노하우, Unix less 쓰는방법을 익힘. 일단 005까지 마무리함

======================= 2016.07.21 (목)
Day 006 - XInput을 받는 방법, Dll 동적 로딩방법, 버추어 키보드 인풋 받기. 6일차 까지 마무리함. 일단 Q&A는 거르고 있음

======================= 2016.07.23 (토)
Day 009 - DSound로 사운드 출력하는 부분은 나의 주 관심사가 아니기 때문에 코드만 타이핑하고 넘어감.

======================= 2016.07.27 (수)
Day 010 - 퍼포먼스 측정법에 대해서 학습. 역시 Q&A는 건너뛰자 ㅋ

======================= 2017.03.16 (목)
// Note
cl 
/Zi : 디버깅 정보를 사용합니다.
/FC : 진단에 전체 경로 이름을 사용합니다.

devenv win32_handmade.exe
이렇게 하면 비주얼 스튜디오로 디버깅을 시작한다.
https://msdn.microsoft.com/ko-kr/library/aa291235(v=vs.71).aspx

/misc/shell.bat를 먼저 실행시켜야 작동함.

game_offscreen_buffer Buffer = {}; // 이렇게 초기화하면 스트럭쳐의 모든 값이 null로 채워진다.

// Day 011 완료

======================= 2017.03.20 (월)
// Note
game output sound 를 공통 코드로 빼는 작업 진행.

VirtualAlloc
https://msdn.microsoft.com/query/dev14.query?appId=Dev14IDEF1&l=KO-KR&k=k(MEMORYAPI%2FVirtualAlloc);k(VirtualAlloc);k(DevLang-C%2B%2B);k(TargetOS-Windows)&rd=true
http://3dmpengines.tistory.com/1408
버추어 어드레스 공간에서 할당되는 malloc은 "확정" 상태만 있다면 virtualAlloc은 "예약" 상태가 추가로 있는 메모리 할당 함수이다.
이 "예약"만 한 상태에서는 물리적 메모리가 전혀 소모되지 않고, 오직 "확정"일때만 실제로 할당된다.
=> 그러니깐 예약(Reserve)만 하고 확정(Commit)하지 않으면, 가상 메모리에서는 메모리를 할당하지만 실제 물려있는 물리적 메모리에는 할당하지 않는다.

// Day 012 완료

======================= 2017.03.21 (화)
// Day 013 코드 부분만 완성. 강의 들어야함.

======================= 2017.03.22 (수)
// Day 013 강의 생략. 컨트롤러 입력 부분이라 스킵함.
// Day 014 코드 부분만 완성. 강의 들어야함.

======================= 2017.03.28 (화)
// Day 014 강의 생략. 그냥 피곤함 ㅋ
// Day 015 완료


======================= 2017.03.29 (수)
// NOTE

[C/C++]
-Z7 일반 > 디버그 정보 형식 : 컴파일러에서 생성되는 디버깅 정보 형식을 지정한다. 이때 호환 가능한 링커 설정이 필요하다.
-W4 일반 > 경고 수준 : 컴파일러가 코드 오류를 처리하는 수준. 현재 4레벨
-WX 일반 > 경고를 오류로 처리
-Od 최적화 > 최적화 : 코드 최적화 사용 안함
-Oi 최적화 > 내장 함수 사용 : 내장 함수를 사용하면 더 빠르지만 더 큰 코드가 생성된다.
-Gm- 코드 생성 > 최소 다시 빌드 가능 : 변경된 C++ 클래스 정의(헤더(.h) 파일에 저장됨)를 포함하는 C++ 소스 파일을 다시 컴파일해야 하는지 여부를 결정하는 최소 다시 빌드를 사용한다. -> 아니요
-EHa- 코드 생성 > C++ 예외 처리 가능 : 컴파일러가 사용하는 예외 처리 모델을 지정. SEH 예외 있음.
-MT 코드 생성 > 런타임 라이브러리 : 다중 스레드
-GR- 언어 > 런타임 형식 정보 사용 : 런타임에 C++ 개체의 형식(런타임 형식 정보)를 검사하는 코드를 추가한다. -> 아니요
-wd4201 -wd4100 -wd4189 고급 > 특정 경고 사용안함
-FC 진단 메시지에 전체 경로를 사용


[링커]
-nologo 일반 > 시작 배너 표시 안 함 : 저작권 메시지와 버전 번호가 표시되지 않음.
-Fm 디버깅 > 맵 파일 생성, 맵 파일 이름 : 맵 파일을 만들도록 링커에 지시할 수 있다.
-subsystem:windows 시스템 > 하위 시스템 : 운영체제에서 .exe 파일을 실행하는 방법을 지시할 수 있다.
-opt:ref 최적화 > 참조 : 참조되지 않은 함수 및/또는 데이터가 제거

// Day 016 완료


======================= 2017.03.30 (목)
// Day 017 완료


======================= 2017.04.01 (토)
// Day 018 완료


======================= 2017.04.02 (일)
// Day 019 완료
// Day 020 완료

// NOTE
1. ================ /MD, /MT
https://msdn.microsoft.com/ko-kr/library/2kzt1wy3.aspx
https://msdn.microsoft.com/ko-kr/library/abx4dbyh.aspx
http://www.gpgstudy.com/forum/viewtopic.php?t=8332
https://msdn.microsoft.com/ko-kr/library/ms235460.aspx

CRT라는 C-런타임 오브젝트들은 파일 핸들이라던지 환경변수들 로케일, printf, strcpy, malloc, new, cin, cout 등등이 이 라이브러리에 포함된다. 이것들은 CRT 라이브러리에 구분되어 지기 때문에(CRT 상태가 CRT 마다 구분되어 존재) a의 CRT 라이브러리 하에서 메모리에 할당된 오브젝트는 b의 CRT 라이브러리에서 메모리를 해제할때 힙 메모리 에러를 내게 된다.(그 외 여러가지 에러)
그렇기 때문에 CRT 오브젝트들을 할당하고 해제하는데는 왠만하면 해당 dll 안에서 모두 처리하도록 하는것이 좋다.
여기에서 빌드 옵션중
/MD는 멀티 쓰레디드 동적 라이브러리 옵션이고(shared dll - MSVCRT.lib)
/MT는 멀티 쓰레디드 정적 라이브러리 옵션이다.(static library - LIBCMT.lib)
즉, 
	/MD로 빌드하면 컴파일러가 MSVCRT.lib를 .obj 파일에 배치하게 된다. 요고는 정적 라이브러리지만 실제 작업 코드가 포함된 MSVCR(versionnumber).dll을 외부 참조하는 코드 계층을 제공한다.(일종의 래퍼인듯) 그렇기 때문에 모든 윈도우 폴더내에 존재하는 MSVCR.dll을 동적으로 할당해서 사용하는것이다.

	/MT는 빌드하면 컴파일러가 LIBCMT.lib를 .obj 파일에 포함하게 된다. 이것 자체가 스태틱(정적) 라이브러리이기 때문에 실행파일이나 dll 파일에 포함된다.
	그렇기 때문에 빌드 용량이 커지게 된다.

/MD 로 빌드된 라이브러리 혹은 실행파일 간에는 CRT 라이브러리를 동일하게 공유하게되기 때문에(윈도우 폴더 내에 있는 동적 라이브러리인 MSCVR.dll) 실행파일, dll들 간의 바운더리를 넘어서 할당/해제가 문제 없지만
/MT는 같은 버전이라도 정적으로 라이브러리 및 실행파일에 각각의 CRT 라이브러리가 포함되기 때문에 서로 동일한 카피의 CRT라이브러리를 사용하지 않으므로 오브젝트 할당/해제의 위치가 다를 시 에러가 나게 된다.

주의점은 이미 제공된 dll을 받을때, 이 dll이 컴파일된 환경에 의해서 msvcr.dll이 정해 지기 때문에 라이브러리를 로드하여 실행하는 환경에서 이 dll이 없거나 실행파일이 다른 msvcr.dll 버전으로 빌드되었다면 런타일 에러가 나게 된다. 그렇기 때문에 제공된 dll을 버전을 맞춰서 빌드하거나 해야된다.

또한 실행파일과 라이브러리의 /MD, /MT 가 다를 경우 런타일 에러가 날 가능성이 크다. 두 정적, 동적 라이브러리는 동일한 코드를 제공하기 때문에 두개의 그룹중에 하나만 포함되어 있어야 한다. 그렇기 때문에 사용하는 라이브러리에 맞춰서 /MD, /MT를 맞춰 줘야한다.

/MD 옵션으로 생성한 라이브러리를 /MT로 설정된 실행파일에서 사용하면 LIBCMT.lib에서 다음과 같은 오류가 발생한다.
error LNK2005:_exit는 이미 LIBCMTD.lib(crt0dat.obj)에 정의되어 있습니다.
-> 정적으로 이미 C런타임 라이브러리가 존재하는데 동적으로 C런타임 라이브러리를 사용하므로.

/MT 옵션으로 생성한 라이브러리를 /MD에서는 아래와 같은 경고가 발생한다.
LNK:warningLNK4098:defaultlib'LIBCMT'는 다른 라이브러리의 사용과 경쟁하고 있습니다.
-> 동적으로 C런타임 라이브러리를 로드해서 사용하는데 이미 라이브러리에는 정적 C런타임이 존재함.
1. ================

2. ================ /LD
DLL을 만드는 구문이지만 비주얼 스튜디오에서는 프로젝트 설정으로 지정해 주기 때문에 무시된다. cl의 커맨드라인 컴파일에서는 사용한다.
DLLMain 함수가 있어야하지만 없으면 TRUE를 반환하는 DllMain 함수를 링커가 삽입한다.
/Fe(파일이름지정) 하면 dll파일 이름을 지정할 수 있다. 없으면 basename이 사용됨.
/MT가 암시적으로 사용됨.
2. ================

// Day 021 완료
// Day 022 코드 부분만 완성. 강의 들어야함.


======================= 2017.04.03 (월)
// Day 022 완료
// Day 023 완료


======================= 2017.04.04 (화)
// Day 024 완료
// Day 025 코드 부터 다시 보자 집중 못했음.


======================= 2017.04.05 (수)
// NOTE
======== 메모리 맵
https://msdn.microsoft.com/ko-kr/library/windows/desktop/aa366537(v=vs.85).aspx
http://egloos.zum.com/sweeper/v/2990023
http://blog.daum.net/lekingjang/16
물리적인 파일을 가상 메모리와 맵핑하여 마치 파일을 메모리처럼 다루는 기법.
운영체제가 실행 파일(exe) 및 dll을 읽어오고 실행하는 내부적인 방법도 바로 메모리 맵 파일이다.
파일을 메모리처럼 사용해도 운영체제가 철저하게 관리를 책임지며 포인터로 파일을 엑세스하면 RAM으로 스왑할 것이고 오랫동안 사용하지 않으면 다시 파일에 기록하며 파일 맵핑을 닫을 때 대기중인 모든 출력이 파일에 완전히 기록된다.

// Day 025 코드완료. 메모리 맵이라는 개념을 배운 알찬 시간이였음.


======================= 2017.04.06 (목)
// Day 025 완료
// Day 026 22분 부터 보자. 넘 피곤하다(게임 아키텍쳐 설명하는 동영상만 진행)


======================= 2017.04.07 (금)
// Day 026 완료
// Day 027 코드완료. 강의 봐야함.















