https://hero.handmade.network/episodes

======================= 2016.07.15 (금) 
Day 003 까지 복습했음. 004할 차례

======================= 2016.07.19 (화)
Day 005 - 27분경 까지 학습. 코딩은 다쳐놨기 때문에 동영상만 쭉 보면 될듯

======================= 2016.07.20 (수)
Day 005 - 약간의 디버깅 노하우, Unix less 쓰는방법을 익힘. 일단 005까지 마무리함

======================= 2016.07.21 (목)
Day 006 - XInput을 받는 방법, Dll 동적 로딩방법, 버추어 키보드 인풋 받기. 6일차 까지 마무리함. 일단 Q&A는 거르고 있음

======================= 2016.07.23 (토)
Day 009 - DSound로 사운드 출력하는 부분은 나의 주 관심사가 아니기 때문에 코드만 타이핑하고 넘어감.

======================= 2016.07.27 (수)
Day 010 - 퍼포먼스 측정법에 대해서 학습. 역시 Q&A는 건너뛰자 ㅋ

======================= 2017.03.16 (목)
// Note
cl 
/Zi : 디버깅 정보를 사용합니다.
/FC : 진단에 전체 경로 이름을 사용합니다.

devenv win32_handmade.exe
이렇게 하면 비주얼 스튜디오로 디버깅을 시작한다.
https://msdn.microsoft.com/ko-kr/library/aa291235(v=vs.71).aspx

/misc/shell.bat를 먼저 실행시켜야 작동함.

game_offscreen_buffer Buffer = {}; // 이렇게 초기화하면 스트럭쳐의 모든 값이 null로 채워진다.

// Day 011 완료

======================= 2017.03.20 (월)
// Note
game output sound 를 공통 코드로 빼는 작업 진행.

VirtualAlloc
https://msdn.microsoft.com/query/dev14.query?appId=Dev14IDEF1&l=KO-KR&k=k(MEMORYAPI%2FVirtualAlloc);k(VirtualAlloc);k(DevLang-C%2B%2B);k(TargetOS-Windows)&rd=true
http://3dmpengines.tistory.com/1408
버추어 어드레스 공간에서 할당되는 malloc은 "확정" 상태만 있다면 virtualAlloc은 "예약" 상태가 추가로 있는 메모리 할당 함수이다.
이 "예약"만 한 상태에서는 물리적 메모리가 전혀 소모되지 않고, 오직 "확정"일때만 실제로 할당된다.
=> 그러니깐 예약(Reserve)만 하고 확정(Commit)하지 않으면, 가상 메모리에서는 메모리를 할당하지만 실제 물려있는 물리적 메모리에는 할당하지 않는다.

// Day 012 완료

======================= 2017.03.21 (화)
// Day 013 코드 부분만 완성. 강의 들어야함.

======================= 2017.03.22 (수)
// Day 013 강의 생략. 컨트롤러 입력 부분이라 스킵함.
// Day 014 코드 부분만 완성. 강의 들어야함.

======================= 2017.03.28 (화)
// Day 014 강의 생략. 그냥 피곤함 ㅋ
// Day 015 완료


======================= 2017.03.29 (수)
// NOTE

[C/C++]
-Z7 일반 > 디버그 정보 형식 : 컴파일러에서 생성되는 디버깅 정보 형식을 지정한다. 이때 호환 가능한 링커 설정이 필요하다.
-W4 일반 > 경고 수준 : 컴파일러가 코드 오류를 처리하는 수준. 현재 4레벨
-WX 일반 > 경고를 오류로 처리
-Od 최적화 > 최적화 : 코드 최적화 사용 안함
-Oi 최적화 > 내장 함수 사용 : 내장 함수를 사용하면 더 빠르지만 더 큰 코드가 생성된다.
-Gm- 코드 생성 > 최소 다시 빌드 가능 : 변경된 C++ 클래스 정의(헤더(.h) 파일에 저장됨)를 포함하는 C++ 소스 파일을 다시 컴파일해야 하는지 여부를 결정하는 최소 다시 빌드를 사용한다. -> 아니요
-EHa- 코드 생성 > C++ 예외 처리 가능 : 컴파일러가 사용하는 예외 처리 모델을 지정. SEH 예외 있음.
-MT 코드 생성 > 런타임 라이브러리 : 다중 스레드
-GR- 언어 > 런타임 형식 정보 사용 : 런타임에 C++ 개체의 형식(런타임 형식 정보)를 검사하는 코드를 추가한다. -> 아니요
-wd4201 -wd4100 -wd4189 고급 > 특정 경고 사용안함
-FC 진단 메시지에 전체 경로를 사용


[링커]
-nologo 일반 > 시작 배너 표시 안 함 : 저작권 메시지와 버전 번호가 표시되지 않음.
-Fm 디버깅 > 맵 파일 생성, 맵 파일 이름 : 맵 파일을 만들도록 링커에 지시할 수 있다.
-subsystem:windows 시스템 > 하위 시스템 : 운영체제에서 .exe 파일을 실행하는 방법을 지시할 수 있다.
-opt:ref 최적화 > 참조 : 참조되지 않은 함수 및/또는 데이터가 제거

// Day 016 완료


======================= 2017.03.30 (목)
// Day 017 완료


======================= 2017.04.01 (토)
// Day 018 완료


======================= 2017.04.02 (일)
// Day 019 완료
// Day 020 완료

// NOTE
1. ================ /MD, /MT
https://msdn.microsoft.com/ko-kr/library/2kzt1wy3.aspx
https://msdn.microsoft.com/ko-kr/library/abx4dbyh.aspx
http://www.gpgstudy.com/forum/viewtopic.php?t=8332
https://msdn.microsoft.com/ko-kr/library/ms235460.aspx

CRT라는 C-런타임 오브젝트들은 파일 핸들이라던지 환경변수들 로케일, printf, strcpy, malloc, new, cin, cout 등등이 이 라이브러리에 포함된다. 이것들은 CRT 라이브러리에 구분되어 지기 때문에(CRT 상태가 CRT 마다 구분되어 존재) a의 CRT 라이브러리 하에서 메모리에 할당된 오브젝트는 b의 CRT 라이브러리에서 메모리를 해제할때 힙 메모리 에러를 내게 된다.(그 외 여러가지 에러)
그렇기 때문에 CRT 오브젝트들을 할당하고 해제하는데는 왠만하면 해당 dll 안에서 모두 처리하도록 하는것이 좋다.
여기에서 빌드 옵션중
/MD는 멀티 쓰레디드 동적 라이브러리 옵션이고(shared dll - MSVCRT.lib)
/MT는 멀티 쓰레디드 정적 라이브러리 옵션이다.(static library - LIBCMT.lib)
즉, 
	/MD로 빌드하면 컴파일러가 MSVCRT.lib를 .obj 파일에 배치하게 된다. 요고는 정적 라이브러리지만 실제 작업 코드가 포함된 MSVCR(versionnumber).dll을 외부 참조하는 코드 계층을 제공한다.(일종의 래퍼인듯) 그렇기 때문에 모든 윈도우 폴더내에 존재하는 MSVCR.dll을 동적으로 할당해서 사용하는것이다.

	/MT는 빌드하면 컴파일러가 LIBCMT.lib를 .obj 파일에 포함하게 된다. 이것 자체가 스태틱(정적) 라이브러리이기 때문에 실행파일이나 dll 파일에 포함된다.
	그렇기 때문에 빌드 용량이 커지게 된다.

/MD 로 빌드된 라이브러리 혹은 실행파일 간에는 CRT 라이브러리를 동일하게 공유하게되기 때문에(윈도우 폴더 내에 있는 동적 라이브러리인 MSCVR.dll) 실행파일, dll들 간의 바운더리를 넘어서 할당/해제가 문제 없지만
/MT는 같은 버전이라도 정적으로 라이브러리 및 실행파일에 각각의 CRT 라이브러리가 포함되기 때문에 서로 동일한 카피의 CRT라이브러리를 사용하지 않으므로 오브젝트 할당/해제의 위치가 다를 시 에러가 나게 된다.

주의점은 이미 제공된 dll을 받을때, 이 dll이 컴파일된 환경에 의해서 msvcr.dll이 정해 지기 때문에 라이브러리를 로드하여 실행하는 환경에서 이 dll이 없거나 실행파일이 다른 msvcr.dll 버전으로 빌드되었다면 런타일 에러가 나게 된다. 그렇기 때문에 제공된 dll을 버전을 맞춰서 빌드하거나 해야된다.

또한 실행파일과 라이브러리의 /MD, /MT 가 다를 경우 런타일 에러가 날 가능성이 크다. 두 정적, 동적 라이브러리는 동일한 코드를 제공하기 때문에 두개의 그룹중에 하나만 포함되어 있어야 한다. 그렇기 때문에 사용하는 라이브러리에 맞춰서 /MD, /MT를 맞춰 줘야한다.

/MD 옵션으로 생성한 라이브러리를 /MT로 설정된 실행파일에서 사용하면 LIBCMT.lib에서 다음과 같은 오류가 발생한다.
error LNK2005:_exit는 이미 LIBCMTD.lib(crt0dat.obj)에 정의되어 있습니다.
-> 정적으로 이미 C런타임 라이브러리가 존재하는데 동적으로 C런타임 라이브러리를 사용하므로.

/MT 옵션으로 생성한 라이브러리를 /MD에서는 아래와 같은 경고가 발생한다.
LNK:warningLNK4098:defaultlib'LIBCMT'는 다른 라이브러리의 사용과 경쟁하고 있습니다.
-> 동적으로 C런타임 라이브러리를 로드해서 사용하는데 이미 라이브러리에는 정적 C런타임이 존재함.
1. ================

2. ================ /LD
DLL을 만드는 구문이지만 비주얼 스튜디오에서는 프로젝트 설정으로 지정해 주기 때문에 무시된다. cl의 커맨드라인 컴파일에서는 사용한다.
DLLMain 함수가 있어야하지만 없으면 TRUE를 반환하는 DllMain 함수를 링커가 삽입한다.
/Fe(파일이름지정) 하면 dll파일 이름을 지정할 수 있다. 없으면 basename이 사용됨.
/MT가 암시적으로 사용됨.
2. ================

// Day 021 완료
// Day 022 코드 부분만 완성. 강의 들어야함.


======================= 2017.04.03 (월)
// Day 022 완료
// Day 023 완료


======================= 2017.04.04 (화)
// Day 024 완료
// Day 025 코드 부터 다시 보자 집중 못했음.


======================= 2017.04.05 (수)
// NOTE
======== 메모리 맵
https://msdn.microsoft.com/ko-kr/library/windows/desktop/aa366537(v=vs.85).aspx
http://egloos.zum.com/sweeper/v/2990023
http://blog.daum.net/lekingjang/16
물리적인 파일을 가상 메모리와 맵핑하여 마치 파일을 메모리처럼 다루는 기법.
운영체제가 실행 파일(exe) 및 dll을 읽어오고 실행하는 내부적인 방법도 바로 메모리 맵 파일이다.
파일을 메모리처럼 사용해도 운영체제가 철저하게 관리를 책임지며 포인터로 파일을 엑세스하면 RAM으로 스왑할 것이고 오랫동안 사용하지 않으면 다시 파일에 기록하며 파일 맵핑을 닫을 때 대기중인 모든 출력이 파일에 완전히 기록된다.

// Day 025 코드완료. 메모리 맵이라는 개념을 배운 알찬 시간이였음.


======================= 2017.04.06 (목)
// Day 025 완료
// Day 026 22분 부터 보자. 넘 피곤하다(게임 아키텍쳐 설명하는 동영상만 진행)


======================= 2017.04.07 (금)
// Day 026 완료
// Day 027 코드완료. 강의 봐야함.


======================= 2017.04.08 (토)
// Day 027 완료. 일단 중요한 부분이 아니면 빨리빨리 넘기자. 생각보다 꾸준히 하고 있다. Keep going!!
// Day 028 코드 완료. 강의 스킵. 간단하네.
// Day 029 코드 완료. 요것도 간단함. 강의 스킵.
// Day 030 완료.
// Day 031 코드 완료. 강의 29분부터.


======================= 2017.04.09 (일)
// Day 031 완료. 별겨 없었음. 그냥 지금 픽셀단위로 이동 속도가 계산되니까 해상도가 작아지면 빨라지는 문제가 있으므로 단위 설정변수를 추가함.
// Day 032 완료. 픽셀 좌표로 핸들링하던것을 미터단위로 변경. 드로윙할때만 픽셀로 치환. 강의 스킵.
// Day 033 완료.
// Day 034 코드까지 완료. 강의 들어야함


======================= 2017.04.10 (월)
// Day 034 완료.
// Day 035 코드까지 완료. 강의 들어야함.


======================= 2017.04.11 (화)
// Day 035 완료.


======================= 2017.04.21 (목)
// NOTE
#pragma pack - push, pop
http://javawoo.tistory.com/30
http://kama1204.tistory.com/entry/%EA%B5%AC%EC%A1%B0%EC%B2%B4-%EA%B5%AC%EC%A1%B0%EC%B2%B4-%EB%A9%94%EB%AA%A8%EB%A6%AC-pragma-packpushpop

바이트패딩을 지정할 수 있는 지정자.
32비트는 4바이트, 64비트는 8바이트 단위로 패딩. 각 x86/x64 CPU 마다 해당 바이트로 처리하는것이 가장 빠르기 때문. 구조체를 사용할때 바이트 패딩에 주의하여 멤버를 배치하자.

// Day 036 코드 완료. 강의 봐야함.


======================= 2017.05.11(목)
// Day 036 완료.
// Day 037 코드 완료. 강의 봐야함.


======================= 2017.05.16(화)
// Day 037 완료.
// Day 038 코드 완료. 강의 봐야함. - 이제 코드에서 끝내지 말고 강의 보고 끝내자!!


======================= 2017.05.16(수)
// NOTE
- BMP 헤더의 R, G, B 마스크를 얻어서 해당 비트의 컬러값을 구해와야 된다. 파일마다 마스크가 다를 수 있다.
- 알파 블렌딩은 선형 보간(1.0 - t)으로 한다. 나중에 더해지는(Source) 픽셀이 t의 가중치(=알파값)이며 기존 픽셀은 1.0 - t 의 가중치를 가진다.

// Day 038 완료.
// Day 039 완료.


======================= 2017.05.17(목)
// NOTE
Raymond Chen. 윈도우에 관한 질문답이나 아티클은 이사람께 짱임. 최고라고 함.

// Day 040 완료.


======================= 2017.05.18(금)
// Day 041 완료.
// Day 042 완료.
// Day 043 코드 완료.


======================= 2017.05.22(월)
// Day 044 코드 완료.
// Day 045 코드 완료.


======================= 2017.05.23(화)
// Day 046 코드 완료. 강의 봐야함


======================= 2017.05.27(토)
// Day 046 완료.


======================= 2017.05.28(일)
// NOTE : 점과 선 충돌 : p1(이동된좌표) = p0(이동전좌표) + d(이동벡터)
pt = p0 + dt 		// 위에서 t는 1.
ps = p0 + ds 		// 충돌을 검사할 위치 ps를 알면 가중치 s를 알 수 있다.
s = (ps - p0) / d 	// 여기서 d, ps, p0값을 모두 알기 때문에 가중치 s를 구하면 가중치 s가 1보다 작으면 p0 < ps < p1 이다. 즉. Wall ps는 나의 전 위치와 후 위치 사이에 있어서 충돌이 된 것이다.

민코프스키 베이식 컬리전은 점과 선 충돌을 체크할때 Collider의 박스는 네면을 선으로 체크하면되는데 
Entity를 점이 아니라 박스로 체크할 수 있는 방법은
Entity의 반지름을 s로 Collider의 반지름을 r이라고 했을때, 점과 s+r의 박스와의 충돌로 처리한다.

// Day 047 코드 완료. 벡터 렝스라 패스
// Day 048 코드 완료. 선분 검사라 패스
// Day 049 코드 완료. 디버깅 코드라 패스
// Day 050 코드 완료. 민코프스키 컬리전 체크이해 OK라 패스
