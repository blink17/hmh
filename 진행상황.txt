https://hero.handmade.network/episodes

======================= 2016.07.15 (금) 
Day 003 까지 복습했음. 004할 차례

======================= 2016.07.19 (화)
Day 005 - 27분경 까지 학습. 코딩은 다쳐놨기 때문에 동영상만 쭉 보면 될듯

======================= 2016.07.20 (수)
Day 005 - 약간의 디버깅 노하우, Unix less 쓰는방법을 익힘. 일단 005까지 마무리함

======================= 2016.07.21 (목)
Day 006 - XInput을 받는 방법, Dll 동적 로딩방법, 버추어 키보드 인풋 받기. 6일차 까지 마무리함. 일단 Q&A는 거르고 있음

======================= 2016.07.23 (토)
Day 009 - DSound로 사운드 출력하는 부분은 나의 주 관심사가 아니기 때문에 코드만 타이핑하고 넘어감.

======================= 2016.07.27 (수)
Day 010 - 퍼포먼스 측정법에 대해서 학습. 역시 Q&A는 건너뛰자 ㅋ

======================= 2017.03.16 (목)
// Note
cl 
/Zi : 디버깅 정보를 사용합니다.
/FC : 진단에 전체 경로 이름을 사용합니다.

devenv win32_handmade.exe
이렇게 하면 비주얼 스튜디오로 디버깅을 시작한다.
https://msdn.microsoft.com/ko-kr/library/aa291235(v=vs.71).aspx

/misc/shell.bat를 먼저 실행시켜야 작동함.

game_offscreen_buffer Buffer = {}; // 이렇게 초기화하면 스트럭쳐의 모든 값이 null로 채워진다.

// Day 011 완료

======================= 2017.03.20 (월)
// Note
game output sound 를 공통 코드로 빼는 작업 진행.

VirtualAlloc
https://msdn.microsoft.com/query/dev14.query?appId=Dev14IDEF1&l=KO-KR&k=k(MEMORYAPI%2FVirtualAlloc);k(VirtualAlloc);k(DevLang-C%2B%2B);k(TargetOS-Windows)&rd=true
http://3dmpengines.tistory.com/1408
버추어 어드레스 공간에서 할당되는 malloc은 "확정" 상태만 있다면 virtualAlloc은 "예약" 상태가 추가로 있는 메모리 할당 함수이다.
이 "예약"만 한 상태에서는 물리적 메모리가 전혀 소모되지 않고, 오직 "확정"일때만 실제로 할당된다.
=> 그러니깐 예약(Reserve)만 하고 확정(Commit)하지 않으면, 가상 메모리에서는 메모리를 할당하지만 실제 물려있는 물리적 메모리에는 할당하지 않는다.

// Day 012 완료

======================= 2017.03.21 (화)
// Day 013 코드 부분만 완성. 강의 들어야함.

======================= 2017.03.22 (수)
// Day 013 강의 생략. 컨트롤러 입력 부분이라 스킵함.
// Day 014 코드 부분만 완성. 강의 들어야함.

======================= 2017.03.28 (화)
// Day 014 강의 생략. 그냥 피곤함 ㅋ
// Day 015 완료


======================= 2017.03.29 (수)
// NOTE

[C/C++]
-Z7 일반 > 디버그 정보 형식 : 컴파일러에서 생성되는 디버깅 정보 형식을 지정한다. 이때 호환 가능한 링커 설정이 필요하다.
-W4 일반 > 경고 수준 : 컴파일러가 코드 오류를 처리하는 수준. 현재 4레벨
-WX 일반 > 경고를 오류로 처리
-Od 최적화 > 최적화 : 코드 최적화 사용 안함
-Oi 최적화 > 내장 함수 사용 : 내장 함수를 사용하면 더 빠르지만 더 큰 코드가 생성된다.
-Gm- 코드 생성 > 최소 다시 빌드 가능 : 변경된 C++ 클래스 정의(헤더(.h) 파일에 저장됨)를 포함하는 C++ 소스 파일을 다시 컴파일해야 하는지 여부를 결정하는 최소 다시 빌드를 사용한다. -> 아니요
-EHa- 코드 생성 > C++ 예외 처리 가능 : 컴파일러가 사용하는 예외 처리 모델을 지정. SEH 예외 있음.
-MT 코드 생성 > 런타임 라이브러리 : 다중 스레드
-GR- 언어 > 런타임 형식 정보 사용 : 런타임에 C++ 개체의 형식(런타임 형식 정보)를 검사하는 코드를 추가한다. -> 아니요
-wd4201 -wd4100 -wd4189 고급 > 특정 경고 사용안함
-FC 진단 메시지에 전체 경로를 사용


[링커]
-nologo 일반 > 시작 배너 표시 안 함 : 저작권 메시지와 버전 번호가 표시되지 않음.
-Fm 디버깅 > 맵 파일 생성, 맵 파일 이름 : 맵 파일을 만들도록 링커에 지시할 수 있다.
-subsystem:windows 시스템 > 하위 시스템 : 운영체제에서 .exe 파일을 실행하는 방법을 지시할 수 있다.
-opt:ref 최적화 > 참조 : 참조되지 않은 함수 및/또는 데이터가 제거

// Day 016 완료


======================= 2017.03.30 (목)
// Day 017 완료


======================= 2017.04.01 (토)
// Day 018 완료


======================= 2017.04.02 (일)
// Day 019 완료
// Day 020 완료

// NOTE
1. ================ /MD, /MT
https://msdn.microsoft.com/ko-kr/library/2kzt1wy3.aspx
https://msdn.microsoft.com/ko-kr/library/abx4dbyh.aspx
http://www.gpgstudy.com/forum/viewtopic.php?t=8332
https://msdn.microsoft.com/ko-kr/library/ms235460.aspx

CRT라는 C-런타임 오브젝트들은 파일 핸들이라던지 환경변수들 로케일, printf, strcpy, malloc, new, cin, cout 등등이 이 라이브러리에 포함된다. 이것들은 CRT 라이브러리에 구분되어 지기 때문에(CRT 상태가 CRT 마다 구분되어 존재) a의 CRT 라이브러리 하에서 메모리에 할당된 오브젝트는 b의 CRT 라이브러리에서 메모리를 해제할때 힙 메모리 에러를 내게 된다.(그 외 여러가지 에러)
그렇기 때문에 CRT 오브젝트들을 할당하고 해제하는데는 왠만하면 해당 dll 안에서 모두 처리하도록 하는것이 좋다.
여기에서 빌드 옵션중
/MD는 멀티 쓰레디드 동적 라이브러리 옵션이고(shared dll - MSVCRT.lib)
/MT는 멀티 쓰레디드 정적 라이브러리 옵션이다.(static library - LIBCMT.lib)
즉, 
	/MD로 빌드하면 컴파일러가 MSVCRT.lib를 .obj 파일에 배치하게 된다. 요고는 정적 라이브러리지만 실제 작업 코드가 포함된 MSVCR(versionnumber).dll을 외부 참조하는 코드 계층을 제공한다.(일종의 래퍼인듯) 그렇기 때문에 모든 윈도우 폴더내에 존재하는 MSVCR.dll을 동적으로 할당해서 사용하는것이다.

	/MT는 빌드하면 컴파일러가 LIBCMT.lib를 .obj 파일에 포함하게 된다. 이것 자체가 스태틱(정적) 라이브러리이기 때문에 실행파일이나 dll 파일에 포함된다.
	그렇기 때문에 빌드 용량이 커지게 된다.

/MD 로 빌드된 라이브러리 혹은 실행파일 간에는 CRT 라이브러리를 동일하게 공유하게되기 때문에(윈도우 폴더 내에 있는 동적 라이브러리인 MSCVR.dll) 실행파일, dll들 간의 바운더리를 넘어서 할당/해제가 문제 없지만
/MT는 같은 버전이라도 정적으로 라이브러리 및 실행파일에 각각의 CRT 라이브러리가 포함되기 때문에 서로 동일한 카피의 CRT라이브러리를 사용하지 않으므로 오브젝트 할당/해제의 위치가 다를 시 에러가 나게 된다.

주의점은 이미 제공된 dll을 받을때, 이 dll이 컴파일된 환경에 의해서 msvcr.dll이 정해 지기 때문에 라이브러리를 로드하여 실행하는 환경에서 이 dll이 없거나 실행파일이 다른 msvcr.dll 버전으로 빌드되었다면 런타일 에러가 나게 된다. 그렇기 때문에 제공된 dll을 버전을 맞춰서 빌드하거나 해야된다.

또한 실행파일과 라이브러리의 /MD, /MT 가 다를 경우 런타일 에러가 날 가능성이 크다. 두 정적, 동적 라이브러리는 동일한 코드를 제공하기 때문에 두개의 그룹중에 하나만 포함되어 있어야 한다. 그렇기 때문에 사용하는 라이브러리에 맞춰서 /MD, /MT를 맞춰 줘야한다.

/MD 옵션으로 생성한 라이브러리를 /MT로 설정된 실행파일에서 사용하면 LIBCMT.lib에서 다음과 같은 오류가 발생한다.
error LNK2005:_exit는 이미 LIBCMTD.lib(crt0dat.obj)에 정의되어 있습니다.
-> 정적으로 이미 C런타임 라이브러리가 존재하는데 동적으로 C런타임 라이브러리를 사용하므로.

/MT 옵션으로 생성한 라이브러리를 /MD에서는 아래와 같은 경고가 발생한다.
LNK:warningLNK4098:defaultlib'LIBCMT'는 다른 라이브러리의 사용과 경쟁하고 있습니다.
-> 동적으로 C런타임 라이브러리를 로드해서 사용하는데 이미 라이브러리에는 정적 C런타임이 존재함.
1. ================

2. ================ /LD
DLL을 만드는 구문이지만 비주얼 스튜디오에서는 프로젝트 설정으로 지정해 주기 때문에 무시된다. cl의 커맨드라인 컴파일에서는 사용한다.
DLLMain 함수가 있어야하지만 없으면 TRUE를 반환하는 DllMain 함수를 링커가 삽입한다.
/Fe(파일이름지정) 하면 dll파일 이름을 지정할 수 있다. 없으면 basename이 사용됨.
/MT가 암시적으로 사용됨.
2. ================

// Day 021 완료
// Day 022 코드 부분만 완성. 강의 들어야함.


======================= 2017.04.03 (월)
// Day 022 완료
// Day 023 완료


======================= 2017.04.04 (화)
// Day 024 완료
// Day 025 코드 부터 다시 보자 집중 못했음.


======================= 2017.04.05 (수)
// NOTE
======== 메모리 맵
https://msdn.microsoft.com/ko-kr/library/windows/desktop/aa366537(v=vs.85).aspx
http://egloos.zum.com/sweeper/v/2990023
http://blog.daum.net/lekingjang/16
물리적인 파일을 가상 메모리와 맵핑하여 마치 파일을 메모리처럼 다루는 기법.
운영체제가 실행 파일(exe) 및 dll을 읽어오고 실행하는 내부적인 방법도 바로 메모리 맵 파일이다.
파일을 메모리처럼 사용해도 운영체제가 철저하게 관리를 책임지며 포인터로 파일을 엑세스하면 RAM으로 스왑할 것이고 오랫동안 사용하지 않으면 다시 파일에 기록하며 파일 맵핑을 닫을 때 대기중인 모든 출력이 파일에 완전히 기록된다.

// Day 025 코드완료. 메모리 맵이라는 개념을 배운 알찬 시간이였음.


======================= 2017.04.06 (목)
// Day 025 완료
// Day 026 22분 부터 보자. 넘 피곤하다(게임 아키텍쳐 설명하는 동영상만 진행)


======================= 2017.04.07 (금)
// Day 026 완료
// Day 027 코드완료. 강의 봐야함.


======================= 2017.04.08 (토)
// Day 027 완료. 일단 중요한 부분이 아니면 빨리빨리 넘기자. 생각보다 꾸준히 하고 있다. Keep going!!
// Day 028 코드 완료. 강의 스킵. 간단하네.
// Day 029 코드 완료. 요것도 간단함. 강의 스킵.
// Day 030 완료.
// Day 031 코드 완료. 강의 29분부터.


======================= 2017.04.09 (일)
// Day 031 완료. 별겨 없었음. 그냥 지금 픽셀단위로 이동 속도가 계산되니까 해상도가 작아지면 빨라지는 문제가 있으므로 단위 설정변수를 추가함.
// Day 032 완료. 픽셀 좌표로 핸들링하던것을 미터단위로 변경. 드로윙할때만 픽셀로 치환. 강의 스킵.
// Day 033 완료.
// Day 034 코드까지 완료. 강의 들어야함


======================= 2017.04.10 (월)
// Day 034 완료.
// Day 035 코드까지 완료. 강의 들어야함.


======================= 2017.04.11 (화)
// Day 035 완료.


======================= 2017.04.21 (목)
// NOTE
#pragma pack - push, pop
http://javawoo.tistory.com/30
http://kama1204.tistory.com/entry/%EA%B5%AC%EC%A1%B0%EC%B2%B4-%EA%B5%AC%EC%A1%B0%EC%B2%B4-%EB%A9%94%EB%AA%A8%EB%A6%AC-pragma-packpushpop

바이트패딩을 지정할 수 있는 지정자.
32비트는 4바이트, 64비트는 8바이트 단위로 패딩. 각 x86/x64 CPU 마다 해당 바이트로 처리하는것이 가장 빠르기 때문. 구조체를 사용할때 바이트 패딩에 주의하여 멤버를 배치하자.

// Day 036 코드 완료. 강의 봐야함.


======================= 2017.05.11(목)
// Day 036 완료.
// Day 037 코드 완료. 강의 봐야함.


======================= 2017.05.16(화)
// Day 037 완료.
// Day 038 코드 완료. 강의 봐야함. - 이제 코드에서 끝내지 말고 강의 보고 끝내자!!


======================= 2017.05.16(수)
// NOTE
- BMP 헤더의 R, G, B 마스크를 얻어서 해당 비트의 컬러값을 구해와야 된다. 파일마다 마스크가 다를 수 있다.
- 알파 블렌딩은 선형 보간(1.0 - t)으로 한다. 나중에 더해지는(Source) 픽셀이 t의 가중치(=알파값)이며 기존 픽셀은 1.0 - t 의 가중치를 가진다.

// Day 038 완료.
// Day 039 완료.


======================= 2017.05.17(목)
// NOTE
Raymond Chen. 윈도우에 관한 질문답이나 아티클은 이사람께 짱임. 최고라고 함.

// Day 040 완료.


======================= 2017.05.18(금)
// Day 041 완료.
// Day 042 완료.
// Day 043 코드 완료.


======================= 2017.05.22(월)
// Day 044 코드 완료.
// Day 045 코드 완료.


======================= 2017.05.23(화)
// Day 046 코드 완료. 강의 봐야함


======================= 2017.05.27(토)
// Day 046 완료.


======================= 2017.05.28(일)
// NOTE : 점과 선 충돌 : p1(이동된좌표) = p0(이동전좌표) + d(이동벡터)
pt = p0 + dt 		// 위에서 t는 1.
ps = p0 + ds 		// 충돌을 검사할 위치 ps를 알면 가중치 s를 알 수 있다.
s = (ps - p0) / d 	// 여기서 d, ps, p0값을 모두 알기 때문에 가중치 s를 구하면 가중치 s가 1보다 작으면 p0 < ps < p1 이다. 즉. Wall ps는 나의 전 위치와 후 위치 사이에 있어서 충돌이 된 것이다.
// 0 <= s < 1.0 사이면 이동을 완료하기 전에 벽에 도달했다는 것이니깐 충돌이다.
// 1.0 < s 이라면 벽에 도달하기위해서 현재이동값인 d보다 더 이동해야된다는거니깐 벽에 도달하지 못한것이다.
// s < 0 이라면 이동방향 d의 반대편으로 이동해야된다는거니깐 이미 벽을 등진상태.

민코프스키 베이식 컬리전은 점과 선 충돌을 체크할때 Collider의 박스는 네면을 선으로 체크하면되는데 
Entity를 점이 아니라 박스로 체크할 수 있는 방법은
Entity의 반지름을 s로 Collider의 반지름을 r이라고 했을때, 점과 s+r의 박스와의 충돌로 처리한다.

// Day 047 코드 완료. 벡터 렝스라 패스
// Day 048 코드 완료. 선분 검사라 패스
// Day 049 코드 완료. 디버깅 코드라 패스
// Day 050 코드 완료. 민코프스키 컬리전 체크이해 OK라 패스
// 10주차 완료.
// Day 051 코드 완료.
// Day 052 코드 완료. 점프 기능 추가 but 충돌체크는 바닥기준으로 아직. 그리고 컬리전체크 안됨.


======================= 2017.05.29(월)
// NOTE
엔티티 타입을 추가. 
카메라를 벗어난 High 엔티티는 Dormant로 변경해줌. 
카메라 안으로 들어온 Dormant는 High로 변경해줌. Hero, Wall 둘다.
컨트롤중인 엔티티(hero)는 High로 변경해줌(인풋을 받을때 GetEntity때 강제로 Residence타입 변경됨)
-> High인 것만 Physics 부분에서 물리 계산 및 렌더 수행.
// Day 053 코드 완료. 강의 패스

// NOTE
Dormant를 없애고 Low, High로 변경함.
기본 엔티티 이자 움직이지 않는 엔티티는 Low.
움직이고 카메라 바운스 안에 들어오는 엔티티는 High.
Low는 타일맵 기준 좌표를 가지는 기본 엔티티이고 High는 카메라에 상대좌표를 가지는 엔티티
// Day 054 코드 완료. 강의 패스


======================= 2017.05.30(화)
// Day 055 완료.
// 11주차 완료.


======================= 2017.05.31(수)
// Day 056 코드완료. handmade_tile -> handmade_world로 바꾸는 단순 작업이라 강의 패스.

// NOTE - world_entity_block 메모리 재사용
World 는 Chunk단위로 쪼개짐.
Chunk는 Tile 단위로 이루어지지만 Chunk자체는 Tile에 관한 데이터가 없음. 치환 함수만 존재.
world_position은 world_chunk와 Chunk안에서 미터단위 Offset으로 이루어짐
world_chunk는 Chunk좌표와 entity 인덱스 리스트를 가지고 있는 world_entity_block으로 이루어짐. 엔티티 블럭은 링크드리스트도 되어있다.
world_chunk안에서의 엔티티블럭은 정적할당되어 있어서 무조건 하나 - FirstBlock - 는 가지고 있다. 그래서 오브젝트가 꽉차면 다음 링크를 만들어 넣어야되는데
여기서 메모리를 재사용하는 특이한 방식을 사용한다.
world에는 재사용 가능한 FreeBlock이 있어서 이 프리 블럭에 꽉찬 FirstBlock 값을 복사해 넣고 FirstBlock의 넥스트로 값이 복사된 프리블럭을 가리키게 한다음,
FirstBlock의 엔티티 개수를 0으로 초기화하는 방식으로 사용된다. 결국. 오래된 엔티티 들은 링크의 맨뒤로 가게 되는것이다.
반대의 경우인 엔티티의 제거인 경우에는 제거 인덱스를 가지고 있는 링크를 찾고, 그 링크의 인덱스 값을 FirstBlock의 마지막 값으로 덮어씌운다.
FirstBlock의 엔티티 카운트는 당연히 줄여주게 되고 이때 FirstBlock의 엔티티 개수가 0이 되면 FirstBlock의 Next를 FirstBlock에 복사하고 중복된 값이된 Next는
World의 FreeBlock의 링크의 맨앞으로 인서트되어 재사용할 준비를 하게 된다.

메모리를 new를 통해서 동적할당방식이 아닌, 미리 메모리풀을 잡아놓고 사용하는 방식을 사용하고 있어서 
메모리 파편화를 막고 메모리 동적할당시 약간의 성능 오버헤드를 줄이는 대신, 할당된 메모리는 아직까지는 해제할 방법이 없어서 최대한 재사용하면서 사용하게 되는것이다.
혹시 가비지 컬렉터를 구현하게 되면 메모리 시프트를 통해 delete로 구현할 수 있겠다. 메모리 조각모음 혹은 어찌해야할까 ㅋ
그리고 프레임 메모리를 한번 사용해보고 싶다. 프레임이 지날때마다 새로 지워지는 메모리 공간으로써 프레임 때마다 일시적으로 사용되는 메모리를 구현해보고 싶네구려
// Day 057 코드완료. 강의 패스.


======================= 2017.06.01(목)
// Day 058 코드완료. 나무깔고 기타 안나왔던 벽 다시 나오게 하는 자질구레한거라 강의 패스.
// Day 059 코드완료. 몬스타, 패밀리어 추가. 패밀리어는 가장 가까운 히어로 따라다님. 이것도 전부 이해해서 강의 패스.


======================= 2017.06.02(금)
// Day 060 코드완료. HP 히트 포인트 구조체와 UI를 추가했고, 그림자가 땅바닦에 붙어있게 하기 위해 EntityZC 변수를 도입. 강의 패스
// 12주차 완료.


======================= 2017.06.03(토)
// Day 061 코드완료. Sword 엔티티 추가. 강의 패스
// Day 062 코드완료. Sword를 프로젝타일로 던지는 코드 완성. 강의 패스
// Day 063 코드완료. Camera Bounds안에 들어오는 엔티티를 모두 조사하여 HighEntity로 변경 후 RenderAndUpdate를 했던 방식을 Region이라는 개념으로 분리.
// Day 064 handmade_sim_region.h만 했음.


======================= 2017.06.07(수)
// Day 064 코드완료. highEntity를 simEntity로 변경하고 lowEntity는 단순히 월드좌표만 가지고 있음. 나머지 상세 데이터는 simEntity로 이관
// Day 065 코드완료. 캐릭터 생성시 에러남.
// 13주차 완료.


======================= 2017.06.08(목)
// Day 066 코드완료. 에러나는거 수정했고, 컬리전이나 시뮬레이션 객체 표시를 Flag로 대체함.
// Day 067 코드완료. entity에 있던 UpdateXXX 함수 없애고 GameRenderAndUpdate로 들어감.
// Day 068 코드완료. 소드 발사 속도 조절하고 몬스터와 히트 처리를 했는데 제대로 안됨 ㅋ.
// Day 069 handmade.h 만했음.


======================= 2017.06.09(금)
// Day 069 코드완료. Should Collide 라는 변수를 이용해서 Collision맵에 컬리젼을 해도 되는지 묻는다.
// Day 070 코드완료. 앞으로 할 TODO 정리라 별거없음.
// 14주차 완료.


======================= 2017.06.12(월)
// Day 071 코드완료. 3D Position으로 변경함. 버그있음. 다음 회차에서 고쳐질듯.


======================= 2017.06.26(월)
// Day 072 코드완료. 아뭐니 컴파일 에러.
// Day 073 코드완료. 연산자 오버로딩은 언제 추가할꺼니. 컴파일 에러.


======================= 2017.06.26(수)
// Day 074 코드완료. 그냥 별로 관심사 아니다. 충돌처리랑 stair 처리.
// Day 075 코드완료. 원근감 처리한 코드 진짜 조금만 더 손대면 좋을듯, 현재 카메라가 비추는 Z를 알아서 그곳을 기준으로 나누는게 좋지 않을까.
암튼 중점에서 Z가 높을 수록 더 멀어지게 처리해서 높이 있는 간격을 넓어지고 멀리있는 간격은 좁게하여 원근감을 줌.
// 15주차 완료.


======================= 2017.07.20(목)
// Day 076 코드완료. 각 액터의 디멘션(치수라고 해야되나?)을 설정하는 코드 추가.
// Day 077 코드완료. 그냥 Stair 박스 다시 그리고 위치 조정하는 정도?


======================= 2017.07.27(목)
// Day 078 코드완료. 컬리전 볼륨을 생성해서 충돌처리
// Day 079 코드완료.


======================= 2017.08.16(수)
// Day 080 코드완료. EntityOverLap() 함수 추가 및 좀 더 충돌을 잘 수행하도록 수정.
// Day 081 코드완료. 잔디와 돌, 잡초 들 같은 바닦을 랜덤 제네레이트 하는 코드 추가.


======================= 2017.08.17(목)
// Day 082 코드완료. loaded_bitmap 구조체로 드로우 구조 변경.
// Day 083 코드완료. premultiplied alpha 강의 듣자. 궁금하다잉. 듣진 않았지만 왜 premultiplied alpha를 사용하는지는 찾아봤다.
// NOTE
https://developer.nvidia.com/content/alpha-blending-pre-or-not-pre
premultiplied alpha 는 비트맵을 읽을때 원본 이미지자체에 알파를 미리 곱해 놓는 방법이다.
그래서 알파 블렌드 할때
기존 Post 방식에서
dest.rgb = (source.rgb * source.a) + (dest.rgb * (1-source.a))
Pre 방식으로
dest.rgb = (source.rgb * one(1이라는 거다. 미리 알파가 곱해져서 계산되어 졌으니깐)) + (dest.rgb * (1-source.a))
변경해야 한다. 왜 프리멀티플라이드 알파를 사용하냐. 밉맵에서 서로 근접한 픽셀들을 하나로 합칠때 두 픽셀의 평균값을 내는데
Post방식의 픽셀의 평균값은 의도하지 않은 색상을 추출하기 때문이다. 이것은 알파 때문인데 알파의 가중치가 고려되지 않고 더해서 평균을
낸것이기 때문에 알파값이 크든 작든 두색상은 동일한 비율로 더해지게 된다. 하지만 Pre방식으로 미리 알파가 계산되어 rgb의 색상의 가중치가
정해진 후 두 색상을 평균을 내면 올바른 색상결과 값을 얻을 수 있다.


======================= 2017.08.19(토)
// Day 084 코드완료. 그런데 premultiplied alpha하고 나서부터 화면이 이상하게 나온다. diff로 확인해보자. 확인완료.
// Day 085 코드완료. 그라운드를 그리는 비트맵은 transient 메모리를 사용한다. 사용하고 반납하게
// Day 086 코드완료. 월드 청크에 맞춰서 그라운드 버퍼를 기록하고 배치함.


======================= 2017.08.20(일)
// Day 087 코드완료. 심리스 그라운드 비트맵 구현. 관심사항이 아닌데 언능 지나가자
// Day 088 코드완료. render_group이라는 렌더링 전용 구조체 생성. 엔티티와 분리.
// NOTE
- 렌더 그룹
render_group		// 렌더 그룹은 하나의 엔티티를 표현하는 묶음
	render_base		// 렌더 그룹내에 공통적으로 공유되는 기본 정보들. 트랜스폼 정보 등등
	PushBufferBase	// 렌더 그룹내에 차일드로 붙는 컴포넌트들 개념
		entity_visible_piece 여러개		// 렌더 그룹의 외형을 결정하는 외형 비트맵 데이터. 여러개 존재 가능(머리, 몸, 팔, 다리, 망토 등등)
		
- 트랜지션트스토리지
메모리에 할당해놓은 TransientStorage를 transient_state로 형변환하고 transient_state 구조체 사이즈를 빼고난 나머지 전체 TransientStorage의 메모리를
TranState(transient_state)의 TranArena(memory_arena)로 사용한다. 처음 이니셜라이즈 할때 그라운드 버퍼를 위한 공간을 미리 할당해 놓는다.
매 틱마다 렌더링 용도의 임시 메모리로 사용한다(RenderMemory-RenderGroup)

// Day 089 코드완료. entity_visible_piece를 타입에 따라 세분화 하여 리팩토링.
// Day 090 코드완료. 벡터 멤버 변수를 소문자로 변경. 그외 함수 리팩토링. 선형대수에 대해서 강의 시작.
// Day 091 코드완료. 데카르트 좌표계 도입.


======================= 2017.08.21(월)
// Day 092 코드완료. 사각형 내에 좌표가 존재하는지 테스트.각 축에 대한 수직 좌표를 구해서 inner테스트.


======================= 2017.08.23(수)
// Day 093 코드완료. 텍스쳐를 읽어서 UV좌표를 따고 주위 픽셀과 색을 보간해서 회전시켜도 픽셀이 깨지지않게함.
// Day 094 코드완료. 감마 공간 - 선형 공간에 대해서 알게된 좋은 시간이였다.
// NOTE
모니터는 광자를 선형적으로 증가시키질 못한다. 그래서 pow(x, 2.2)라는 감마 곡선으로 색을 출력한다.
그렇기 때문에 하드디스크에 이미지가 저장될때 감마 공간이라는 pow(x, 1/2.2)를 계산해서 넣은 이미지로 저장된다.
모니터에 출력될때 pow(x, 2.2)의 효과가 적용되어 출력되기 때문에 원본 이미지를 재현 할 수 있다.
이미지가 원본보다 좀 더 밝은 감마공간(pow(x, 1/2.2)에서 저장되기 때문에 쉐이더 연산을 바로 수행하면
밝은 감마 공간에서 수행되는 것이기 때문에 올바르지 않은 결과가 나오게 된다.
그렇기 때문에 쉐이더 연산하기 전에 감마공간 -> 선형공간으로 변환하여 계산을 모두 수행한 후
최종 컬러에 대해서 다시 선형공간 -> 감마공간으로 변형한다. 끗.


======================= 2017.08.24(목)
// Day 095 코드완료. 컴파일러 최적화 옵션 추가 및 render_entity_* header와 분리
// NOTE
최적화 옵션
https://msdn.microsoft.com/en-us/library/chh3fb0k.aspx
https://msdn.microsoft.com/en-us/library/ms235601.aspx
https://msdn.microsoft.com/en-us/library/dn785163.aspx
- 렌더 그룹
render_group		// 렌더 그룹은 하나의 엔티티를 표현하는 묶음
	render_base		// 렌더 그룹내에 공통적으로 공유되는 기본 정보들. 트랜스폼 정보 등등
	PushBufferBase	// 렌더 그룹내에 차일드로 붙는 컴포넌트들 개념
		render_group_entry_header + render_entry_* 	// 렌더 헤더와 렌더 엔트리가 한묶음으로 버퍼에 들어간다. 외형 정보가지고 있다.

// Day 096 코드완료. 라이팅에 대한 강의니깐 27분부터 다시 듣자.